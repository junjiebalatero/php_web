/*=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~ElectroServerAS object version 2.01Last Edit 6/27/2002--Written by Jobe Makar to work with the ElectroServer socket server created by Mike GrundvigFind updates to this ActionScript and the server here: http://www.electrotank.com/ElectroServeror here:http://www.gamebook.net--ElectroServerAS object was created to make chat and multiplayer game creation very easy. With themethods and properties provided by ElectroServerAS you will not have to write a single line of XML.For a full description of the features and documentation of ElectroServer and ElectroServerAS and for the most recentversions, visit http://www.electrotank.com/ElectroServer--Note: WDDX_MX.as is needed also. It must be in the same directory as this file. If you don'thave WDDX_MX.as you can download it from http://www.electrotank.com/ElectroServer or fromhttp://chattyfig.figleaf.comWDDX_MX.as was created by Branden Hall of Fig Leaf Software. It is an object serializer/deserializerWhat that means for us is that we can easily send ActionScript objects between clients--ElectroServer and ElectroServerAS are owned by Electrotank, Inc and cannot be resold or distributedwithout the express permission of Electrotank, Inc=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~=~*/#include "WDDX_MX.as"ElectroServerAS = function () {	this.history = "";	this.isConnected = false;	this.inGame = false;	this.isResponding = false;	this.leaveAlone = false;	this.challenging = false;	this.roomVars = {};	_global.ElectroServer = this;};//Lazy shortcutES = ElectroServerAS.prototype;ES.server = new XMLSocket();ES.server.ES = ES;XML.prototype.ignoreWhite = true;ES.connectResponse = function(success) {	ES.isConnected = success;	//only send a trigger the conection callback if the connection is failed	//this is because the socket may connect yet ElectroServer still can refuse	if (!ES.isConnected) {		ES.onConnection(success);	}};ES.server.onConnect = ES.connectResponse;ES.login = function(user, password) {	//password is optional	if (password == null) {		var password = "";	}	var xml = "<action>Login</action><name>"+user+"</name><password>"+password+"</password>";	this.username = user;	this.sendData(xml);};ES.sendData = function(xml) {	var infoToSend = "<doc>"+xml+"</doc>";	this.server.send(infoToSend);};ES.connectToServer = function() {	this.server.connect(this.IP, this.port);};ES.disconnectFromServer = function() {	this.server.close();};ES.getRoomList = function() {	return this.rooms;};ES.kick = function(who, why) {	if (why == null) {		var why = "No reason given."	}	var info = "<action>Kick</action><name>"+who+"</name><why>"+why+"</why>";	this.sendData(info);};ES.ban = function(who, why) {	if (why == null) {		var why = "No reason given."	}	var info = "<action>Ban</action><name>"+who+"</name><why>"+why+"</why>";	this.sendData(info);};ES.server.onClose = function() {	ES.onClose();};ES.parseRoomList = function(info) {	var content = info.firstChild.nextSibling;	this.totalUsers = Number(content.attributes.totalusers);	var temp = [];	var temp = info.firstChild.nextSibling.childNodes;	this.rooms = [];	for (var i = 0; i<temp.length; ++i) {		var name = temp[i].firstChild.nodeValue;		var usersInRoom = Number(temp[i].attributes.num);		this.rooms.push({name:name, total:usersInRoom});		if (name == this.myRoom) {			this.usersInMyRoom = usersInRoom;		}	}	if (this.onPlayersInRoomChange != undefined) {		this.onPlayersInRoomChange(this.usersInMyRoom);	}	this.roomListChanged(this.rooms);};ES.getUserList = function() {	return this.users;};ES.addToHistory = function(msg) {	//possible memory hog. pay attention to this area	this.history += msg;	return this.history;};ES.purgeHistory = function () {	this.history = "";}ES.getHistory = function() {	return this.history;};ES.parseUserList = function(info) {	var content = info.firstChild.nextSibling;	var temp = [];	var temp = info.firstChild.nextSibling.childNodes;	this.users = [];	for (var i = 0; i<temp.length; ++i) {		var name = temp[i].firstChild.nodeValue;		this.users.push({name:name});	}	this.userListChanged(this.users);};ES.addUser = function(info) {	var name = info.firstChild.nextSibling.firstChild.nodeValue;	this.users.push({name:name});	this.userListChanged(this.users);};ES.removeUser = function(info) {	var name = info.firstChild.nextSibling.firstChild.nodeValue;	if (name == this.areChallenging && !inGame) {		this.challengeDeclined("autodeclined");	} else if (name == this.challenger && this.isResponding) {		this.challengeCancelled();	}	for (var i = 0; i<this.users.length; ++i) {		if (name == this.users[i].name) {			this.users.splice(i, 1);			break;		}	}	this.userListChanged(this.users);};ES.createVariable = function(name, value, deleteOnExit, locked) {	//creates a variable on the server in the current room	if (deleteOnExit == null || deleteOnExit == true || deleteOnExit == "true" || deleteOnExit == "True") {		var deleteOnExit = "True";	} else if (deleteOnExit == false || deleteOnExit == "false" || deleteOnExit == "False") {		var deleteOnExit = "False";	}	if (locked == true || locked == "true" || locked == "True") {		var locked = "True";	} else if (locked == null || locked == false || locked == "false" || locked == "False") {		var locked = "False";	}	var msg = "<action>UpdateRoomVariable</action><auxData><variable deleteOnExit=\""+deleteOnExit+"\" locked=\""+locked+"\"><user>"+this.username+"</user><name>"+name+"</name><value>"+value+"</value></variable></auxData>";	ES.sendData(msg);};ES.deleteVariable = function(name) {	//deletes a room variable from the server	var msg = "<action>DeleteRoomVariable</action><auxData><variable><name>"+name+"</name></variable></auxData>";	ES.sendData(msg);};ES.challenge = function(who, game) {	if (!this.isResponding) {		var room = game+random(1000000);		var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"Challenge\" Game=\""+game+"\" Room=\""+room+"\"><from>"+this.username+"</from><body></body></message></auxData>";		this.pendingRoom = room;		this.challenging = true;		this.areChallenging = who;		this.sendData(info);	}};ES.cancelChallenge = function() {	var who = this.areChallenging;	var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"CancelChallenge\" ><from>"+this.username+"</from><body></body></message></auxData>";	this.pendingRoom = null;	this.challenging = false;	this.sendData(info);};ES.sendMessage = function(msg, who) {	if (who == "room" || who == undefined || who.toLowerCase()== "all" ) {		//the default is to send a message to the room		who = "All";	}	if (who.toLowerCase() == "all") {		var info = "<action>SendMessage</action><sendTo>All</sendTo><auxData><message Type=\"Public\"><from>"+this.username+"</from><body>"+msg+"</body></message></auxData>";	} else {		var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"Private\"><from>"+this.username+"</from><body>"+msg+"</body></message></auxData>";	}	this.sendData(info);};ES.sendSystemMessage = function(msg) {	var info = "<action>SystemMessage</action><message>"+msg+"</message>";	this.sendData(info);};ES.joinRoom = function(room) {	if (room != this.myRoom) {		var info = "<action>JoinRoom</action><roomName updatable=\"true\" hidden=\"false\">"+room+"</roomName>";		this.myRoom = room;		this.inGame = false;		this.sendData(info);	}};ES.chatMessageReceived = function(from, body, type) {	if (type == "public" || type == "private") {		this.chatReceiver({from:from, body:body, type:type});	}};ES.joinGame = function() {	this.joinRoom(this.pendingRoom);	this.inGame = true;};ES.acceptChallenge = function() {	var room = this.pendingRoom;	var who = this.challenger;	var game = this.pendingGame;	var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"Accepted\" Game=\""+game+"\" Room=\""+room+"\"><from>"+this.username+"</from><body></body></message></auxData>";	this.isResponding = false;	this.opponent = who;	this.player = 2;	this.sendData(info);};ES.autoDecline = function(who) {	var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"AutoDeclined\"><from>"+this.username+"</from><body></body></message></auxData>";	this.sendData(info);};ES.declineChallenge = function() {	var who = this.challenger;	var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"Declined\"><from>"+this.username+"</from><body></body></message></auxData>";	this.isResponding = false;	this.sendData(info);};ES.roomVariableList = function(info) {	this.roomVars = {};	var temp = [];	var temp = info.firstChild.nextSibling.firstChild.childNodes;	for (var i = 0; i<temp.length; ++i) {		var node = temp[i];		var name = node.firstChild.firstChild.nodeValue;		var value = node.firstChild.nextSibling.firstChild.nodeValue;		this.roomVars[name] = value;	}	this.onRoomVarChange(this.roomVars, "list");};ES.roomVariableUpdate = function(info) {	var temp = [];	var name = info.firstChild.nextSibling.firstChild.firstChild.firstChild.nodeValue;	var value = info.firstChild.nextSibling.firstChild.firstChild.nextSibling.firstChild.nodeValue;	this.roomVars[name] = value;	this.onRoomVarChange(this.roomVars, "update", name);};ES.roomVariableDelete = function(info) {	var temp = [];	var name = info.firstChild.nextSibling.firstChild.firstChild.firstChild.nodeValue;	delete this.roomVars[name];	this.onRoomVarChange(this.roomVars, "delete", name);};ES.sendMove = function(who, what) {	//this uses Branden Hall's WDDX_MX.as file	//it serializes an ActionScript object (as XML) and sends it. It is then rebuilt on the other side	// ...amazing... :-)	var myXML = new XML();	var foo = new WDDX();	var myXML = foo.serialize(what);	if (who.toLowerCase() == "all") {		var info = "<action>SendMessage</action><sendTo>All</sendTo><auxData><message Type=\"Move\"><from>"+this.username+"</from><body>"+myXML+"</body></message></auxData>";	} else {		var info = "<action>SendMessage</action><sendTo>"+who+"</sendTo><auxData><message Type=\"Move\"><from>"+this.username+"</from><body>"+myXML+"</body></message></auxData>";	}	this.sendData(info);};ES.moveArrived = function(what) {	//ActionScript object arrived, deserialize it (i.e. convert it from XML to ActionScript)	var what = what.firstChild.firstChild.nextSibling.firstChild;	var foo = new WDDX();	var ob = foo.deserialize(what);	this.moveReceived(ob);};ES.challengeAccepted = function(info) {	var from = info.firstChild.firstChild.firstChild.nodeValue;	var room = info.firstChild.attributes.room;	var game = info.firstChild.attributes.game;	if (this.challenging) {		this.player = 1;	}	this.opponent = from;	this.challengeAnswered("accepted");};ES.challengeDeclined = function(type) {	this.challenging = false;	var type = type.toLowerCase();	this.challengeAnswered(type);};ES.challengeAborted = function() {	this.isResponding = false;	this.challengeCancelled();};ES.challengeArrived = function(info) {	var from = info.firstChild.firstChild.firstChild.nodeValue;	var room = info.firstChild.attributes.room;	var game = info.firstChild.attributes.game;	if (this.inGame || this.leaveAlone || this.isResponding || this.challenging) {		//send and auto decline message		this.autoDecline(from);	} else {		//let the user know about the challenge		this.isResponding = true;		this.pendingRoom = room;		this.challenger = from;		this.pendingGame = game;		this.challengeReceived(from, game);	}};ES.goKicked = function (info) {	var msg = info.firstChild.nextSibling.firstChild.nodeValue;	ES.kicked(msg)}ES.goBanned = function (info) {	var msg = info.firstChild.nextSibling.firstChild.nodeValue;	ES.banned(msg)}ES.connectionRefused = function(info) {	var msg = info.firstChild.nextSibling.firstChild.nodeValue;	this.onConnectionRefused(msg);};ES.received = function(info) {	info = info.firstChild;	var action = info.firstChild.firstChild.nodeValue.toLowerCase();	//trace(info);	if (action == "connectionrefused") {		ES.connectionRefused(info);	} else if (action == "kick") {		ES.goKicked(info)	} else if (action == "ban") {		ES.goBanned(info)	} else if (action == "roomlist") {		ES.parseRoomList(info);		return;	} else if (action == "userlist") {		ES.parseUserList(info);		return;	} else if (action == "userjoined") {		ES.addUser(info);		return;	} else if (action == "userleft") {		ES.removeUser(info);		return;	} else if (action == "connectionaccepted") {		ES.onConnection(true);		return;	} else if (action == "roomvariablelist") {		ES.roomVariableList(info);		return;	} else if (action == "updateroomvariable") {		ES.roomVariableUpdate(info);		return;	} else if (action == "deleteroomvariable") {		ES.roomVariableDelete(info);		return;	} else if (action == "loginresponse") {		var response = info.firstChild.nextSibling.firstChild.nodeValue.toLowerCase();		if (response == "accepted") {			//login accepted			ES.loginResponse(true);			return;		} else if (response == "denied") {			//login failed			var reason = info.firstChild.nextSibling.nextSibling.firstChild.nodeValue;			ES.loginResponse(false, reason);			return;		}	} else if (action == undefined) {		//if no action is specified then we end up here		var messageType = info.firstChild.attributes.type.toLowerCase();		if (messageType == "public" || messageType == "private") {			var body = info.firstChild.firstChild.nextSibling.firstChild.nodeValue;			var from = info.firstChild.firstChild.firstChild.nodeValue;			ES.chatmessageReceived(from, body, messageType);			return;		} else if (messageType == "challenge") {			ES.challengeArrived(info);			return;		} else if (messageType == "accepted") {			ES.challengeAccepted(info);			return;		} else if (messageType == "cancelchallenge") {			ES.challengeAborted();			return;		} else if (messageType == "declined" || messageType == "autodeclined") {			ES.challengeDeclined(messageType);			return;		} else if (messageType == "move") {			ES.moveArrived(info);			return;		}	}};ES.server.onXML = ES.received;